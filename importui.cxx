// generated by Fast Light User Interface Designer (fluid) version 1.0304

#include "importui.h"

Fl_Menu_Item ImportUI::menu_drawMode[] = {
 {"Normal", 0,  0, (void*)(-1), 0, (uchar)FL_NORMAL_LABEL, 0, 11, 0},
 {"50%+50%", 0,  0, (void*)(0), 0, (uchar)FL_NORMAL_LABEL, 0, 11, 0},
 {"100%+100%", 0,  0, (void*)(1), 0, (uchar)FL_NORMAL_LABEL, 0, 11, 0},
 {"100%-100%", 0,  0, (void*)(2), 0, (uchar)FL_NORMAL_LABEL, 0, 11, 0},
 {"100%+25%", 0,  0, (void*)(3), 0, (uchar)FL_NORMAL_LABEL, 0, 11, 0},
 {"STP Mask", 0,  0, (void*)(4), 0, (uchar)FL_NORMAL_LABEL, 0, 11, 0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Menu_Item ImportUI::menu_depthChoice[] = {
 {"4-bit", 0,  0, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {"8-bit", 0,  0, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {"16-bit", 0,  0, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {"24-bit", 0,  0, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Menu_Item ImportUI::menu_quantizeMode[] = {
 {"Simple", 0,  0, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {"Xiaolin Wu", 0,  0, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {"NeuQuant", 0,  0, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {0,0,0,0,0,0,0,0,0}
};
ImportUI::ImportUI(int X, int Y, int W, int H, const char *L)
  : Fl_Double_Window(X, Y, W, H, L) {
  _ImportUI();
}

ImportUI::ImportUI(int W, int H, const char *L)
  : Fl_Double_Window(0, 0, W, H, L) {
  clear_flag(16);
  _ImportUI();
}

ImportUI::ImportUI()
  : Fl_Double_Window(0, 0, 540, 410, "Import Options") {
  clear_flag(16);
  _ImportUI();
}

void ImportUI::_ImportUI() {
this->box(FL_FLAT_BOX);
this->color(FL_BACKGROUND_COLOR);
this->selection_color(FL_BACKGROUND_COLOR);
this->labeltype(FL_NO_LABEL);
this->labelfont(0);
this->labelsize(14);
this->labelcolor(FL_FOREGROUND_COLOR);
this->align(Fl_Align(FL_ALIGN_TOP));
this->when(FL_WHEN_RELEASE);
{ preview = new Fl_Scroll(191, 20, 342, 355, "Preview");
  preview->box(FL_FLAT_BOX);
  preview->color((Fl_Color)40);
  preview->labelsize(12);
  preview->align(Fl_Align(FL_ALIGN_TOP_LEFT));
  preview->end();
  Fl_Group::current()->resizable(preview);
} // Fl_Scroll* preview
{ Fl_Group* o = new Fl_Group(5, 380, 528, 23);
  { drawMode = new Fl_Choice(368, 380, 85, 15, "Mode");
    drawMode->down_box(FL_BORDER_BOX);
    drawMode->labelsize(11);
    drawMode->textsize(11);
    drawMode->callback((Fl_Callback*)cb_ImportDrawMode);
    drawMode->when(FL_WHEN_CHANGED);
    drawMode->menu(menu_drawMode);
  } // Fl_Choice* drawMode
  { zoomValue = new Fl_Spinner(493, 380, 40, 15, "Zoom");
    zoomValue->labelsize(11);
    zoomValue->maximum(8);
    zoomValue->textsize(11);
    zoomValue->callback((Fl_Callback*)cb_ImportZoom);
  } // Fl_Spinner* zoomValue
  { okayButton = new Fl_Return_Button(5, 380, 89, 23, "Ok");
    okayButton->labelsize(12);
    okayButton->callback((Fl_Callback*)cb_ImportOkay);
  } // Fl_Return_Button* okayButton
  { Fl_Button* o = new Fl_Button(96, 380, 90, 23, "Cancel");
    o->labelsize(12);
    o->callback((Fl_Callback*)cb_ImportCancel);
  } // Fl_Button* o
  { Fl_Group* o = new Fl_Group(191, 380, 29, 23);
    o->end();
    Fl_Group::current()->resizable(o);
  } // Fl_Group* o
  o->end();
} // Fl_Group* o
{ Fl_Tabs* o = new Fl_Tabs(6, 3, 180, 372);
  { Fl_Group* o = new Fl_Group(6, 20, 180, 355, "Conversion");
    o->labelsize(12);
    { Fl_Group* o = new Fl_Group(11, 39, 170, 108, "Color Conversion");
      o->box(FL_ENGRAVED_BOX);
      o->labelsize(12);
      o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      { srcDepth = new Fl_Value_Output(106, 44, 70, 15, "Original Bpp");
        srcDepth->box(FL_FLAT_BOX);
        srcDepth->labelsize(12);
        srcDepth->textsize(12);
      } // Fl_Value_Output* srcDepth
      { depthChoice = new Fl_Choice(106, 64, 70, 20, "Target Bpp");
        depthChoice->tooltip("Specifies the color depth the texture will be converted too.");
        depthChoice->down_box(FL_BORDER_BOX);
        depthChoice->labelsize(12);
        depthChoice->textsize(12);
        depthChoice->callback((Fl_Callback*)cb_ImportDepthChoice);
        depthChoice->menu(menu_depthChoice);
      } // Fl_Choice* depthChoice
      { ditherToggle = new Fl_Check_Button(16, 129, 160, 15, "Dithering");
        ditherToggle->tooltip("Dither the image to improve smoothness of gradients (only works when using Si\
mple quantizer and 16-bit color depth).");
        ditherToggle->down_box(FL_DOWN_BOX);
        ditherToggle->labelsize(12);
        ditherToggle->callback((Fl_Callback*)cb_ImportDither);
      } // Fl_Check_Button* ditherToggle
      { quantizeMode = new Fl_Choice(106, 86, 70, 21, "Quantizer");
        quantizeMode->tooltip("Specifies the color quantization algorithm to use in converting the source im\
age to lower color depths.");
        quantizeMode->down_box(FL_BORDER_BOX);
        quantizeMode->labelsize(12);
        quantizeMode->textsize(12);
        quantizeMode->callback((Fl_Callback*)cb_ImportQuantChoice);
        quantizeMode->menu(menu_quantizeMode);
      } // Fl_Choice* quantizeMode
      { vmWidth = new Fl_Value_Output(106, 110, 70, 14, "Texture Width");
        vmWidth->box(FL_FLAT_BOX);
        vmWidth->labelsize(12);
        vmWidth->textsize(12);
      } // Fl_Value_Output* vmWidth
      o->end();
    } // Fl_Group* o
    { stpOptions = new Fl_Group(11, 161, 170, 39, "Semi-Transparency Options");
      stpOptions->box(FL_ENGRAVED_BOX);
      stpOptions->labelsize(12);
      stpOptions->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      { stpNonBlack = new Fl_Check_Button(16, 166, 160, 15, "Set STP on Non Black");
        stpNonBlack->tooltip("Colors that are not pure black will be set with a STP bit, which will be draw\
n semi-transparently if semi-transparency is enabled.");
        stpNonBlack->down_box(FL_DOWN_BOX);
        stpNonBlack->labelsize(12);
        stpNonBlack->callback((Fl_Callback*)cb_ImportUpdate);
      } // Fl_Check_Button* stpNonBlack
      { stpBlack = new Fl_Check_Button(16, 182, 160, 15, "Set STP on Full Black");
        stpBlack->tooltip("Colors that are pure black will be set with a STP bit, which will be drawn op\
aque.");
        stpBlack->down_box(FL_DOWN_BOX);
        stpBlack->labelsize(12);
        stpBlack->callback((Fl_Callback*)cb_ImportUpdate);
      } // Fl_Check_Button* stpBlack
      stpOptions->end();
    } // Fl_Group* stpOptions
    { Fl_Group* o = new Fl_Group(6, 361, 180, 14);
      o->end();
      Fl_Group::current()->resizable(o);
    } // Fl_Group* o
    { Fl_Group* o = new Fl_Group(11, 215, 170, 145, "Transparency Mask");
      o->box(FL_ENGRAVED_BOX);
      o->labelsize(12);
      o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      { stpNormal = new Fl_Check_Button(16, 220, 160, 15, "Pure Black");
        stpNormal->tooltip("Transparency is specified by pixels that are pure black.");
        stpNormal->type(102);
        stpNormal->down_box(FL_DOWN_BOX);
        stpNormal->labelsize(12);
        stpNormal->callback((Fl_Callback*)cb_ImportUpdate);
      } // Fl_Check_Button* stpNormal
      { stpAlpha = new Fl_Check_Button(16, 238, 160, 15, "Alpha Channel");
        stpAlpha->tooltip("Uses the alpha channel (if available) of the source image as the transparency\
 mask. Pure black pixels will be set with a STP bit if the alpha of the pixel \
is greater than the threshold.");
        stpAlpha->type(102);
        stpAlpha->down_box(FL_DOWN_BOX);
        stpAlpha->labelsize(12);
        stpAlpha->callback((Fl_Callback*)cb_ImportUpdate);
      } // Fl_Check_Button* stpAlpha
      { alphaCtrls = new Fl_Group(18, 253, 158, 53);
        alphaCtrls->box(FL_ENGRAVED_BOX);
        alphaCtrls->labelsize(12);
        alphaCtrls->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        alphaCtrls->deactivate();
        { alphaValue = new Fl_Value_Input(126, 259, 45, 21, "Alpha Threshold");
          alphaValue->tooltip("Specifies the alpha value to be considered as fully transparent.");
          alphaValue->labelsize(12);
          alphaValue->maximum(255);
          alphaValue->step(1);
          alphaValue->value(127);
          alphaValue->textsize(12);
          alphaValue->callback((Fl_Callback*)cb_ImportUpdateV);
        } // Fl_Value_Input* alphaValue
        { stpAlphaValue = new Fl_Value_Input(126, 280, 45, 21, "STP Threshold");
          stpAlphaValue->tooltip("Specifies the alpha value to be considered as semi transparent. A value less \
than Alpha Threshold disables this feature.");
          stpAlphaValue->labelsize(12);
          stpAlphaValue->maximum(255);
          stpAlphaValue->step(1);
          stpAlphaValue->value(255);
          stpAlphaValue->textsize(12);
          stpAlphaValue->callback((Fl_Callback*)cb_ImportUpdateV);
        } // Fl_Value_Input* stpAlphaValue
        alphaCtrls->end();
      } // Fl_Group* alphaCtrls
      { colorKey = new Fl_Check_Button(16, 311, 160, 15, "Color Key/Index");
        colorKey->tooltip("Use color key or color index to use as a transparency mask.");
        colorKey->type(102);
        colorKey->down_box(FL_DOWN_BOX);
        colorKey->labelsize(12);
        colorKey->callback((Fl_Callback*)cb_ImportUpdate);
      } // Fl_Check_Button* colorKey
      { colorKeyCtrls = new Fl_Group(18, 327, 158, 28);
        colorKeyCtrls->box(FL_ENGRAVED_BOX);
        colorKeyCtrls->deactivate();
        { Fl_Button* o = new Fl_Button(46, 331, 60, 20, "Select");
          o->tooltip("Select color key from a color chooser.");
          o->labelsize(12);
          o->callback((Fl_Callback*)cb_ImportSetColorKey);
        } // Fl_Button* o
        { pickButton = new Fl_Button(111, 331, 60, 20, "Pick");
          pickButton->tooltip("Pick a color by clicking on the image.");
          pickButton->type(1);
          pickButton->labelsize(12);
          pickButton->callback((Fl_Callback*)cb_ImportColorPick);
        } // Fl_Button* pickButton
        { colorKeyBox = new Fl_Box(22, 331, 20, 20);
          colorKeyBox->box(FL_FLAT_BOX);
          colorKeyBox->color(FL_GRAY0);
          colorKeyBox->labelsize(12);
        } // Fl_Box* colorKeyBox
        colorKeyCtrls->end();
      } // Fl_Group* colorKeyCtrls
      o->end();
    } // Fl_Group* o
    o->end();
    Fl_Group::current()->resizable(o);
  } // Fl_Group* o
  { Fl_Group* o = new Fl_Group(6, 20, 180, 355, "Color Adjust");
    o->labelsize(12);
    o->hide();
    { colorAdjToggle = new Fl_Check_Button(11, 30, 169, 15, "Apply Color Adjust");
      colorAdjToggle->down_box(FL_DOWN_BOX);
      colorAdjToggle->labelsize(12);
      colorAdjToggle->callback((Fl_Callback*)cb_ColorAdjToggle);
    } // Fl_Check_Button* colorAdjToggle
    { Fl_Group* o = new Fl_Group(11, 65, 170, 70, "General");
      o->box(FL_ENGRAVED_BOX);
      o->labelsize(12);
      o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      { generalAdj[0] = new Fl_Value_Slider(29, 71, 147, 19, "R");
        generalAdj[0]->type(1);
        generalAdj[0]->labelsize(12);
        generalAdj[0]->maximum(2);
        generalAdj[0]->value(1);
        generalAdj[0]->textsize(12);
        generalAdj[0]->callback((Fl_Callback*)cb_GeneralColAdj, (void*)(0));
        generalAdj[0]->align(Fl_Align(FL_ALIGN_LEFT));
      } // Fl_Value_Slider* generalAdj[0]
      { generalAdj[1] = new Fl_Value_Slider(29, 91, 147, 19, "G");
        generalAdj[1]->type(1);
        generalAdj[1]->labelsize(12);
        generalAdj[1]->maximum(2);
        generalAdj[1]->value(1);
        generalAdj[1]->textsize(12);
        generalAdj[1]->callback((Fl_Callback*)cb_GeneralColAdj, (void*)(1));
        generalAdj[1]->align(Fl_Align(FL_ALIGN_LEFT));
      } // Fl_Value_Slider* generalAdj[1]
      { generalAdj[2] = new Fl_Value_Slider(29, 111, 147, 19, "B");
        generalAdj[2]->type(1);
        generalAdj[2]->labelsize(12);
        generalAdj[2]->maximum(2);
        generalAdj[2]->value(1);
        generalAdj[2]->textsize(12);
        generalAdj[2]->callback((Fl_Callback*)cb_GeneralColAdj, (void*)(2));
        generalAdj[2]->align(Fl_Align(FL_ALIGN_LEFT));
      } // Fl_Value_Slider* generalAdj[2]
      o->end();
    } // Fl_Group* o
    { Fl_Group* o = new Fl_Group(11, 157, 170, 120, "STP Colors");
      o->box(FL_ENGRAVED_BOX);
      o->labelsize(12);
      o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      { blendAdj[0] = new Fl_Value_Slider(29, 163, 147, 19, "R");
        blendAdj[0]->type(1);
        blendAdj[0]->labelsize(12);
        blendAdj[0]->maximum(2);
        blendAdj[0]->value(1);
        blendAdj[0]->textsize(12);
        blendAdj[0]->callback((Fl_Callback*)cb_BlendColAdj, (void*)(0));
        blendAdj[0]->align(Fl_Align(FL_ALIGN_LEFT));
      } // Fl_Value_Slider* blendAdj[0]
      { blendAdj[1] = new Fl_Value_Slider(29, 183, 147, 19, "G");
        blendAdj[1]->type(1);
        blendAdj[1]->labelsize(12);
        blendAdj[1]->maximum(2);
        blendAdj[1]->value(1);
        blendAdj[1]->textsize(12);
        blendAdj[1]->callback((Fl_Callback*)cb_BlendColAdj, (void*)(1));
        blendAdj[1]->align(Fl_Align(FL_ALIGN_LEFT));
      } // Fl_Value_Slider* blendAdj[1]
      { blendAdj[2] = new Fl_Value_Slider(29, 203, 147, 19, "B");
        blendAdj[2]->type(1);
        blendAdj[2]->labelsize(12);
        blendAdj[2]->maximum(2);
        blendAdj[2]->value(1);
        blendAdj[2]->textsize(12);
        blendAdj[2]->callback((Fl_Callback*)cb_BlendColAdj, (void*)(2));
        blendAdj[2]->align(Fl_Align(FL_ALIGN_LEFT));
      } // Fl_Value_Slider* blendAdj[2]
      { invertChan[0] = new Fl_Check_Button(16, 225, 160, 15, "Invert Red");
        invertChan[0]->down_box(FL_DOWN_BOX);
        invertChan[0]->labelsize(12);
        invertChan[0]->callback((Fl_Callback*)cb_ImportChanInv);
      } // Fl_Check_Button* invertChan[0]
      { invertChan[1] = new Fl_Check_Button(16, 241, 160, 15, "Invert Green");
        invertChan[1]->down_box(FL_DOWN_BOX);
        invertChan[1]->labelsize(12);
        invertChan[1]->callback((Fl_Callback*)cb_ImportChanInv);
      } // Fl_Check_Button* invertChan[1]
      { invertChan[2] = new Fl_Check_Button(16, 257, 160, 15, "Invert Blue");
        invertChan[2]->down_box(FL_DOWN_BOX);
        invertChan[2]->labelsize(12);
        invertChan[2]->callback((Fl_Callback*)cb_ImportChanInv);
      } // Fl_Check_Button* invertChan[2]
      o->end();
    } // Fl_Group* o
    { Fl_Group* o = new Fl_Group(10, 355, 171, 15);
      o->end();
      Fl_Group::current()->resizable(o);
    } // Fl_Group* o
    o->end();
  } // Fl_Group* o
  o->end();
} // Fl_Tabs* o
set_modal();
xclass("timedit.import");
end();
}
